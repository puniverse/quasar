<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.async documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.async.html"><span>co.paralleluniverse.pulsar.async</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.async.html#var-%3C%21%21"><span>&lt;!!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-%3E%21%21"><span>&gt;!!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-alt%21"><span>alt!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-alt%21%21"><span>alt!!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-alts%21"><span>alts!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-alts%21%21"><span>alts!!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-buffer"><span>buffer</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-chan"><span>chan</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-close%21"><span>close!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-dropping-buffer"><span>dropping-buffer</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-go"><span>go</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-put%21"><span>put!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-sliding-buffer"><span>sliding-buffer</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-take%21"><span>take!</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-thread"><span>thread</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-thread-call"><span>thread-call</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html#var-timeout"><span>timeout</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.async documentation</h2><pre class="doc">Implementation of core.async
</pre><div class="public" id="var-%3C%21%21"><h3>&lt;!!</h3><div class="usage"></div><pre class="doc">takes a val from port. Will return nil if closed. Will block 
if nothing is available.

Pulsar implementation: Identical to &lt;!. May be used outside go blocks as well.</pre></div><div class="public" id="var-%3E%21%21"><h3>&gt;!!</h3><div class="usage"></div><pre class="doc">puts a val into port. nil values are not allowed. Will block if no 
buffer space is available. Returns nil.

Pulsar implementation: Identical to &lt;!!. May be used outside go blocks as well.</pre></div><div class="public" id="var-alt%21"><h3>alt!</h3><h4 class="macro">macro</h4><div class="usage"><code>(alt! &amp; clauses)</code></div><pre class="doc">Makes a single choice between one of several channel operations,
as if by alts!, returning the value of the result expr corresponding
to the operation completed. Must be called inside a (go ...) block.

Each clause takes the form of:

channel-op[s] result-expr

where channel-ops is one of:

take-port - a single port to take
[take-port | [put-port put-val] ...] - a vector of ports as per alts!
:default | :priority - an option for alts!

and result-expr is either a list beginning with a vector, whereupon that
vector will be treated as a binding for the [val port] return of the
operation, else any other expression.

(alt!
[c t] ([val ch] (foo ch val))
x ([v] v)
[[out val]] :wrote
:default 42)

Each option may appear at most once. The choice and parking
characteristics are those of alts!.</pre></div><div class="public" id="var-alt%21%21"><h3>alt!!</h3><h4 class="macro">macro</h4><div class="usage"><code>(alt!! &amp; args)</code></div><pre class="doc">Like alt!, except as if by alts!!, will block until completed, and
not intended for use in (go ...) blocks.

Pulsar implementation: identical to alt! and may be
used in go blocks</pre></div><div class="public" id="var-alts%21"><h3>alts!</h3><div class="usage"><code>(alts! ports &amp; {:as opts})</code></div><pre class="doc">Completes at most one of several channel operations. Must be called
inside a (go ...) block. ports is a set of channel endpoints, which
can be either a channel to take from or a vector of
[channel-to-put-to val-to-put], in any combination. Takes will be
made as if by &lt;!, and puts will be made as if by &gt;!. Unless
the :priority option is true, if more than one port operation is
ready a non-deterministic choice will be made. If no operation is
ready and a :default value is supplied, [default-val :default] will
be returned, otherwise alts! will park until the first operation to
become ready completes. Returns [val port] of the completed
operation, where val is the value taken for takes, and nil for puts.

opts are passed as :key val ... Supported options:

:default val - the value to use if none of the operations are immediately ready
:priority true - (default nil) when true, the operations will be tried in order.

Note: there is no guarantee that the port exps or val exprs will be
used, nor in what order should they be, so they should not be
depended upon for side effects.</pre></div><div class="public" id="var-alts%21%21"><h3>alts!!</h3><h4 class="macro">macro</h4><div class="usage"><code>(alts!! &amp; args)</code></div><pre class="doc">Like alts!, except takes will be made as if by &lt;!!, and puts will
be made as if by &gt;!!, will block until completed, and not intended
for use in (go ...) blocks.

Pulsar implementation: identical to alt! and may be
used in go blocks</pre></div><div class="public" id="var-buffer"><h3>buffer</h3><div class="usage"><code>(buffer n)</code></div><pre class="doc">Returns a fixed buffer of size n. When full, puts will block/park.
</pre></div><div class="public" id="var-chan"><h3>chan</h3><div class="usage"><code>(chan)</code><code>(chan buf-or-n)</code></div><pre class="doc">Creates a channel with an optional buffer. If buf-or-n is a number, 
will create and use a fixed buffer of that size.</pre></div><div class="public" id="var-close%21"><h3>close!</h3><div class="usage"><code>(close! chan)</code></div><pre class="doc">Closes a channel. The channel will no longer accept any puts (they
will be ignored). Data in the channel remains available for taking, until
exhausted, after which takes will return nil. If there are any
pending takes, they will be dispatched with nil. Closing a closed
channel is a no-op. Returns nil.</pre></div><div class="public" id="var-dropping-buffer"><h3>dropping-buffer</h3><div class="usage"><code>(dropping-buffer n)</code></div><pre class="doc">Returns a buffer of size n. When full, puts will complete but 
val will be dropped (no transfer).</pre></div><div class="public" id="var-go"><h3>go</h3><h4 class="macro">macro</h4><div class="usage"><code>(go &amp; body)</code></div><pre class="doc">Asynchronously executes the body, returning immediately to the
calling thread. Additionally, any visible calls to &lt;!, &gt;! and alt!/alts!
channel operations within the body will block (if necessary) by
'parking' the calling thread rather than tying up an OS thread (or
the only JS thread when in ClojureScript). Upon completion of the
operation, the body will be resumed.

Returns a channel which will receive the result of the body when
completed</pre></div><div class="public" id="var-put%21"><h3>put!</h3><div class="usage"><code>(put! port val)</code><code>(put! port val fn0)</code><code>(put! port val fn0 on-caller?)</code></div><pre class="doc">Asynchronously puts a val into port, calling fn0 (if supplied) when
complete. nil values are not allowed. Will throw if closed. If
on-caller? (default true) is true, and the put is immediately
accepted, will call fn0 on calling thread.  Returns nil.</pre></div><div class="public" id="var-sliding-buffer"><h3>sliding-buffer</h3><div class="usage"><code>(sliding-buffer n)</code></div><pre class="doc">Returns a buffer of size n. When full, puts will complete, and be 
buffered, but oldest elements in buffer will be dropped (not 
transferred).</pre></div><div class="public" id="var-take%21"><h3>take!</h3><div class="usage"><code>(take! port fn1)</code><code>(take! port fn1 on-caller?)</code></div><pre class="doc">Asynchronously takes a val from port, passing to fn1. Will pass nil
if closed. If on-caller? (default true) is true, and value is
immediately available, will call fn1 on calling thread.
Returns nil.</pre></div><div class="public" id="var-thread"><h3>thread</h3><h4 class="macro">macro</h4><div class="usage"><code>(thread &amp; body)</code></div><pre class="doc">Executes the body in another thread, returning immediately to the
calling thread. Returns a channel which will receive the result of
the body when completed.</pre></div><div class="public" id="var-thread-call"><h3>thread-call</h3><div class="usage"><code>(thread-call f)</code></div><pre class="doc">Executes f in another thread, returning immediately to the calling
thread. Returns a channel which will receive the result of calling
f when completed.</pre></div><div class="public" id="var-timeout"><h3>timeout</h3><div class="usage"><code>(timeout msecs)</code></div><pre class="doc">Returns a channel that will close after msecs
</pre></div></div></body></html>