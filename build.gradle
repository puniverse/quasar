import aQute.bnd.gradle.Bundle
import java.util.jar.JarFile
import java.util.jar.Manifest
import static org.gradle.jvm.toolchain.JavaLanguageVersion.of

plugins {
    id 'com.jfrog.artifactory'
    id 'org.javamodularity.moduleplugin'
    id 'com.github.johnrengelman.shadow'
    id 'com.dorongold.task-tree'
    id 'biz.aQute.bnd.builder' apply false
}

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'org.javamodularity.moduleplugin'

    java {
        toolchain {
            languageVersion = of(11)
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
    }

    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }

    tasks.register('install') {
        dependsOn tasks.named('publishToMavenLocal')
    }

    group               = "co.paralleluniverse"
    version             = quasarVersion
    status              = "integration"
    description         = "Fibers, Channels and Actors for the JVM"
    ext.url             = "http://puniverse.github.com/quasar"
    ext.vendor          = "Parallel Universe Software Co."
    ext.licenseName1    = "The GNU Lesser General Public License, version 3"
    ext.licenseUrl1     = "http://www.gnu.org/licenses/lgpl-3.0.txt"
    ext.licenseName2    = "Eclipse Public License - v 1.0"
    ext.licenseUrl2     = "http://www.eclipse.org/legal/epl-v10.html"
    ext.scmUrl          = "https://github.com/corda/quasar"
    ext.scmConnection   = "https://github.com/corda/quasar.git"
    ext.distDir         = "$buildDir/dist"
    ext.isReleaseVersion = !version.endsWith("SNAPSHOT")
    ext.baselib         = "${rootProject.projectDir}/baselib"
    ext.quasarJar = "${rootProject.projectDir}/quasar-core/build/libs/quasar-core-${version}.jar" // project(':quasar-core').jar.archivePath

    ext.drpWizVer = '4.1.0'
    ext.guavaVer  = '29.0-jre'
    ext.asmVer    = '7.0'
    ext.slf4jVer  = '1.7.30'
    ext.osgiVer   = '7.0.0'

    if (!project.hasProperty('mainClass')) { // must use project.hasProperty() rather than hasProperty in subprojects (gradle bug)
        ext.mainClass = ''
    }

    repositories {
        flatDir {
            dirs baselib
        }
        repositories {
            mavenLocal()
            mavenCentral()
            maven { url "https://oss.sonatype.org/content/repositories/releases" }
            maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
        }
    }

    configurations.all {
        resolutionStrategy {
            dependencySubstitution {
                // The substitution is needed to get ASM 7.0 whilst Kryo still depends on 5.0.4
                substitute module("org.ow2.asm:asm") with module("org.ow2.asm:asm:$asmVer")

                // Kryo demands Objenesis 2.5.1, but Mockito wants Objenesis 2.6
                substitute module("org.objenesis:objenesis") with module("org.objenesis:objenesis:2.5.1")

                // Avoid problem when DropWizard and Log4J ask for different versions of SLF4J.
                substitute module("org.slf4j:slf4j-api") with module("org.slf4j:slf4j-api:$slf4jVer")
            }
            failOnVersionConflict()
        }
    }

    configurations {
        provided
        timewarp
        // markdownDoclet
        shadowedJar.extendsFrom runtimeClasspath
        bundleJar.extendsFrom runtimeClasspath
        agentJar

        compileOnly.extendsFrom provided
        testCompileOnly.extendsFrom compileOnly
        testRuntimeOnly.extendsFrom provided
    }

    sourceSets {
        main {
            output.dir "$buildDir/generated-resources/main", builtBy: 'compileJava'
        }
        jmh {
            compileClasspath += main.compileClasspath + main.output + test.compileClasspath + test.output
            runtimeClasspath += compileClasspath + main.runtimeClasspath + test.runtimeClasspath
        }
    }

    dependencies {

        implementation "io.dropwizard.metrics:metrics-core:$drpWizVer"
        implementation "io.dropwizard.metrics:metrics-jmx:$drpWizVer"
        provided "org.apache.ant:ant:1.10.5"
        implementation ("com.google.guava:guava:$guavaVer") {
            exclude group: 'com.google.errorprone', module: '*'
            exclude group: 'org.checkerframework', module: 'checker-qual'
        }
        timewarp 'co.paralleluniverse:timewarp:0.2.0-SNAPSHOT'
        testImplementation 'org.hamcrest:hamcrest-all:1.3'
        testImplementation('junit:junit:4.12') {
            exclude group: 'org.hamcrest', module: '*'
        }
        testImplementation('com.google.truth:truth:0.42') {
            exclude group: 'com.google.guava', module: 'guava'
            exclude group: 'com.google.errorprone', module: '*'
            exclude group: 'junit', module: 'junit'
        }
        testImplementation("org.mockito:mockito-core:2.23.0") {
            exclude group: "org.ow2.asm", module: '*'
            exclude group: "net.bytebuddy", module: '*'
        }
        testRuntimeOnly "net.bytebuddy:byte-buddy:1.9.2" // for Mockito
        testImplementation "org.ow2.asm:asm:$asmVer"

        jmhImplementation 'org.openjdk.jmh:jmh-core:1.21'
        jmhImplementation 'org.openjdk.jmh:jmh-generator-annprocess:1.21'

        annotationProcessor 'org.kohsuke.metainf-services:metainf-services:1.8'
        // annotationProcessor 'com.google.auto.service:auto-service:1.0-rc1' // same as metainf-services
        // markdownDoclet "ch.raffael.pegdown-doclet:pegdown-doclet:1.1.1"
    }

    //    tasks.withType(JavaCompile) {
    //        // options.compilerArgs << "-Xlint:unchecked"
    //        // options.compilerArgs << "-Xlint:deprecation"
    //    }

    compileJava.dependsOn processResources
    compileJava {
        if (project.name != 'quasar-kotlin') {
            doLast {
                scanAndInstrument(sourceSets.main, [configurations.provided, configurations.runtimeClasspath])
            }
        }
    }

    test.dependsOn jar

    tasks.withType(Test).configureEach {
        useJUnit()

        if (project.name != 'quasar-kotlin') {
            moduleOptions {
                runOnClasspath = true
            }
        }
        // jvmArgs '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
        // systemProperty 'co.paralleluniverse.fibers.verifyInstrumentation', 'true'

        // systemProperty "java.util.logging.config.file", "jul.properties"

        // Uncomment and add ${rootProject.projectDir}/log4j.xml, if not present, for logging
        // systemProperty "log4j.configurationFile", "${rootProject.projectDir}/log4j.xml"

        // systemProperty "Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector"

        // systemProperty 'co.paralleluniverse.debugMode', 'true'
        systemProperty 'co.paralleluniverse.monitoring.flightRecorderLevel', '5'
        systemProperty 'co.paralleluniverse.globalFlightRecorder', 'true'
        systemProperty 'co.paralleluniverse.flightRecorderDumpFile', 'quasar.log'
        systemProperty 'co.paralleluniverse.monitoring.flightRecorderSize', '200000'

        if (project.name != 'quasar-core') {
            jvmArgs "-javaagent:${quasarJar}" // =vdmc (verbose, debug, allow monitors, check class)
        }

        if (project.name != 'quasar-kotlin') { // TODO investigate why kotlin-plugin 1.1.2+ doesn't like it
            jvmArgs "-Xbootclasspath/a:${configurations.timewarp.singleFile}"
            if (System.getenv("TRAVIS") == 'true') {
                jvmArgs "-javaagent:${configurations.timewarp.singleFile}=3" // slow clock down x3
            }
        }

        jvmArgs "-Xmx1024m"
//        jvmArgs "-XX:+TraceClassLoading"
//        jvmArgs "-XX:+TraceClassUnloading"
//        if (!project.ext.java8) {
//            jvmArgs "-XX:MaxPermSize=512m" // Travis is having some trouble with PermGen
//        }
        // jvmArgs "-XX:-UseCompressedOops"

        beforeTest { desc ->
            logger.quiet("Running test: " + desc)
        }

        afterTest { desc, result ->
            if(result.resultType == TestResult.ResultType.FAILURE) {
                logger.quiet("Failed test ${desc.name} [${desc.className}] with exception: ${result.exception}")
                if(result.exception != null) {
                    result.exception.printStackTrace()
                }
            }
        }

        doLast() {
            println "file://" + getReports().getHtml().getDestination() + "/index.html"
        }
    }

    ['run', 'debug'].each { name ->
        project.task(name, type: JavaExec, dependsOn:[testClasses]) {
            classpath = sourceSets.main.runtimeClasspath
            if(project.hasProperty('mainClass')){
                main = project.mainClass
            }
            if(project.hasProperty('args')){
                args project.args.split('\\s+')
            }

            jvmArgs '-Xmx2048m'
            // jvmArgs "-Xbootclasspath/p:${System.getProperty("user.home")}/jsr166.jar"
            // systemProperty 'co.paralleluniverse.fibers.DefaultFiberPool.parallelism', '1'

            systemProperty "log4j.configurationFile", "${rootProject.projectDir}/log4j.xml"
            systemProperty "Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector"
            // systemProperty 'co.paralleluniverse.fibers.verifyInstrumentation', 'true'
            jvmArgs "-javaagent:${quasarJar}" // =vdmc (verbose, debug, allow monitors, check class)

            // jvmArgs '-XX:+UnlockCommercialFeatures', '-XX:+FlightRecorder', '-XX:StartFlightRecording=duration=60s,filename=recording.jfr,settings=heap'
        }
    }
    debug.debug = true

    project.afterEvaluate {
        run.dependsOn project(':quasar-core').tasks.named('shadowJar')

        jar {
            manifest {
                attributes(
                    "Implementation-Title"      :   project.name,
                    "Implementation-Version"    :   archiveVersion.get(),
                    "Implementation-Vendor"     :   vendor,
                    "Automatic-Module-Name"     :   project.moduleName,
                    "Built-By"                  :   System.getProperty("user.name"),
                )
            }
        }
    }

    tasks.withType(JavaExec).configureEach {
        classpath += files(sourceSets.test.runtimeClasspath, sourceSets.test.output, sourceSets.jmh.runtimeClasspath, sourceSets.jmh.output)
    }

    //    tasks.withType(Debug) {
    //        classpath = sourceSets.test.runtimeClasspath
    //    }

    javadoc {
        classpath += configurations.provided
        options {
            addStringOption('Xdoclint:none', '-quiet')
        }
    }

    defaultTasks 'build'

    task sourcesJar(type: Jar, dependsOn: classes) {
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }
    task javadocJar(type: Jar, dependsOn: javadoc) {
        archiveClassifier = 'javadoc'
        from javadoc.destinationDir
    }

    task artifacts {
        group = "Help"
        description = "Displays the artifacts associated with each configuration of " + project
        doFirst {
            configurations.findAll().each { config ->
                println "${config}:"
                // config.allArtifacts.each { file -> println "--- " + file }
                config.allArtifacts.getFiles().each { file -> println "" + file }
                println ' '
            }
        }
    }
}

logger.lifecycle("Gradle version: {}", gradle.gradleVersion)
logger.lifecycle("Java version: {}", JavaVersion.current())
logger.lifecycle("Java source compatibility: {}", sourceCompatibility)
logger.lifecycle("Java target compatibility: {}", targetCompatibility)
logger.lifecycle("Kotlin version: {}", kotlinVersion)
logger.lifecycle("Building quasar version: {}", quasarVersion)

def scanAndInstrument(SourceSet sset, configs) {

    def cp = sset.output.classesDirs.getAsPath() + ':' + sset.output.resourcesDir + ':' + configs*.asPath.join(':')

    // ENT-5598 quasar-kotlin has two output directories, java and kotlin.
    // So we have to cope with multiple directories in classesDirs.

    ant.taskdef(
            name:'scanSuspendables',
            classname:'co.paralleluniverse.fibers.instrument.SuspendablesScanner',
            classpath: cp)
    ant.scanSuspendables(
            auto: false,
            supersFile:"${sset.output.dirs.singleFile}/META-INF/suspendable-supers",
            append: true) {
        for (File f : sset.output.classesDirs) {
            fileset(dir: f)
        }
    }

    ant.taskdef(
            name:'instrumentation',
            classname:'co.paralleluniverse.fibers.instrument.InstrumentationTask',
            classpath: cp)
    ant.instrumentation(verbose:'true', check:'true', debug:'true') {
        for (File f : sset.output.classesDirs) {
            fileset(dir: f) {
                exclude(name: 'co/paralleluniverse/fibers/instrument/*.class')
            }
        }
    }

    // Filter out the 'requires org.objectweb.asm' from quasar-core's module-info, as it will be shadowed into the jar
    ant.taskdef(name:'filterModules', classname:'co.paralleluniverse.fibers.instrument.ModuleFilterTask', classpath: cp)
    ant.filterModules(module: 'org.objectweb.asm') {
        for (File f : sset.output.classesDirs) {
            fileset(dir: f)
        }
    }
}

boolean containsOnly(String values, List<String> expected) {
    expected.containsAll(parsePackages(values))
}

List<String> parsePackages(String values) {
    values.split(',').findAll { !it.startsWith('java.') }
}

String fetchManifestAttributeFrom(File archive, String attributeName) {
    return new JarFile(archive).with { jar ->
        Manifest manifest = jar.manifest
        manifest.mainAttributes.getValue(attributeName)
    }
}

String fetchManifestAttributeFrom(TaskProvider<? extends Jar> task, String attributeName) {
    return fetchManifestAttributeFrom(task.flatMap { it.archiveFile }.get().asFile, attributeName)
}

project (':quasar-core') {
    /*
     * see:
     *   https://docs.gradle.org/current/userguide/java_plugin.html
     *   http://examples.javacodegeeks.com/core-java/gradle/gradle-sourcesets-example/
     *   http://stackoverflow.com/questions/15870662/gradle-create-a-new-jar-from-each-sourceset
     *   http://stackoverflow.com/questions/18190614/compiling-a-project-with-different-java-source-compatibility
     *   https://softnoise.wordpress.com/2014/09/07/gradle-sub-project-test-dependencies-in-multi-project-builds/
     */

    apply plugin: 'com.github.johnrengelman.shadow'

    ext.moduleName = 'co.paralleluniverse.quasar.core'
    
    sourceSets {
        main {
            java {
                srcDir 'src/main/java'
            }
        }
        agent {
            java {
                srcDir 'src/main/agent'
            }
            compileClasspath += main.compileClasspath
        }
        bundle {
            java {
                srcDir 'src/main/bundle'
            }
            compileClasspath += main.compileClasspath
        }

        test {
            java {
                srcDir 'src/test/java'
            }
        }

        jmh {
            java {
                srcDir 'src/jmh/java'
            }

            compileClasspath += main.output + test.compileClasspath + test.output
            runtimeClasspath += compileClasspath + test.runtimeClasspath
        }

        classloadertest {
            java {
                srcDir 'src/classloadertest/java'
            }

            compileClasspath += main.output + test.compileClasspath
            runtimeClasspath += compileClasspath + test.runtimeClasspath
        }
    }

    configurations {
        bundleImplementation.extendsFrom implementation
        bundleImplementation.extendsFrom agentImplementation
    }

    dependencies {
        implementation "org.hdrhistogram:HdrHistogram:2.1.10"
        implementation("org.latencyutils:LatencyUtils:2.0.3") {
            exclude group: "org.hdrhistogram", module: '*'
        }
        provided "org.ow2.asm:asm:$asmVer"
        provided "org.ow2.asm:asm-analysis:$asmVer"
        provided "org.ow2.asm:asm-commons:$asmVer"
        provided "org.ow2.asm:asm-util:$asmVer"

        implementation "com.esotericsoftware:kryo:4.0.2"
        implementation "de.javakaffee:kryo-serializers:0.43"

        provided ('junit:junit:4.12') {
            exclude group: 'org.hamcrest', module: '*'
        }

        compileOnly "org.osgi:osgi.annotation:$osgiVer"

        agentImplementation files(sourceSets.main.output) {
            builtBy tasks.named('compileJava', JavaCompile)
        }
        bundleImplementation files(sourceSets.agent.output) {
            builtBy tasks.named('compileAgentJava', JavaCompile)
        }
    }

    compileAgentJava {
        options.compilerArgs += [
            '--patch-module', "${project.moduleName}.agent=${sourceSets.main.output.asPath}",
            '--module-version', project.version
        ]
    }

    compileBundleJava {
        options.compilerArgs += [
            '--patch-module', "${project.moduleName}.osgi=${sourceSets.main.output.asPath}",
            '--module-path', configurations.bundleCompileClasspath.asPath,
            '--module-version', project.version
        ]
    }

    // this happens after we've filtered the dependency on ASM from core's module-info
    compileTestJava {
        options.compilerArgs += ["--add-modules", "org.objectweb.asm", "--add-reads", "co.paralleluniverse.quasar.core=org.objectweb.asm"]
    }

    tasks.named('jar', Jar) {
        archiveClassifier = 'ignore'
        enabled = false
    }

    def shadowJar = tasks.named('shadowJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
        destinationDirectory = file("$buildDir/libs")
        archiveClassifier = ''

        from sourceSets.main.output

        configurations = [project.configurations.compileClasspath]
        dependencies {
            include(dependency('org.ow2.asm:.*:.*'))
        }
        exclude 'META-INF/INDEX.LIST'

        relocate 'org.objectweb.asm.', 'co.paralleluniverse.asm.'

        manifest {
            attributes(
                "Implementation-Title"      :   project.name,
                "Implementation-Version"    :   archiveVersion.get(),
                "Implementation-Vendor"     :   vendor,
                "Premain-Class"             :   "co.paralleluniverse.fibers.instrument.JavaAgent",
                "Agent-Class"               :   "co.paralleluniverse.fibers.instrument.JavaAgent",
                "Can-Retransform-Classes"   :   "true",
                "Can-Redefine-Classes"      :   "true",
                "Built-By"                  :   System.getProperty("user.name"),
            )
        }
    }

    def bundle = tasks.register('bundle', Bundle) {
        dependsOn shadowJar
        from(zipTree(shadowJar.flatMap { it.archiveFile })) {
            exclude 'META-INF/suspendable*'
            exclude 'co/paralleluniverse/asm/**'
            exclude 'co/paralleluniverse/common/asm/**'
            exclude 'co/paralleluniverse/common/resource/**'
            exclude 'co/paralleluniverse/fibers/instrument/**'
            exclude 'co/paralleluniverse/fibers/suspend/**'
            exclude 'module-info.class'
        }
        from(sourceSets.bundle.output)
        archiveAppendix = 'osgi'

        manifest {
            attributes(
                "Built-By"                  :   System.getProperty("user.name"),
                "Implementation-Title"      :   project.name,
                "Implementation-Version"    :   archiveVersion.get(),
                "Implementation-Vendor"     :   vendor,
            )
        }

        bnd """
Bundle-SymbolicName: co.paralleluniverse.quasar-core
Bundle-Name: Quasar Fibers
Bundle-Version: \${project.version}
Import-Package: \
 org.LatencyUtils.*;resolution:=optional,\
 org.HdrHistogram.*;resolution:=optional,\
 org.junit.*;resolution:=optional,\
 *
"""
    }

    def validateBundle = tasks.register("validateBundle") {
        dependsOn bundle
        doLast {
            String importPackages = fetchManifestAttributeFrom(bundle, 'Import-Package')
            if (importPackages && !parsePackages(importPackages).disjoint(['co.paralleluniverse.asm'])) {
                throw new InvalidUserCodeException("OSGi bundle should not import shaded ASM package: " + importPackages)
            }
        }
    }

    bundle.configure {
        it.finalizedBy validateBundle
    }

    def agentBundle = tasks.register("agentBundle", Bundle) {
        dependsOn shadowJar
        from(zipTree(shadowJar.flatMap { it.archiveFile })) {
            include 'META-INF/suspendable*'
            include 'co/paralleluniverse/asm/**'
            include 'co/paralleluniverse/common/asm/**'
            include 'co/paralleluniverse/common/resource/**'
            include 'co/paralleluniverse/fibers/instrument/**'
            exclude 'co/paralleluniverse/fibers/instrument/InstrumentationTask*'
            exclude 'co/paralleluniverse/fibers/instrument/InstrumentationTKB*'
            exclude 'co/paralleluniverse/fibers/instrument/ModuleFilterTask*'
            exclude 'co/paralleluniverse/fibers/instrument/OldSuspendablesScanner*'
            exclude 'co/paralleluniverse/fibers/instrument/SuspendablesScanner*'
            include 'co/paralleluniverse/fibers/suspend/**'
        }
        from(sourceSets.agent.output)
        archiveAppendix = 'osgi'
        archiveClassifier = 'agent'

        bnd shadowJar.flatMap { jar ->
            jar.archiveFile.map { file ->
                "-include: jar:${file.asFile.toURI()}!/META-INF/MANIFEST.MF"
            }
        }

        bnd """
Bundle-SymbolicName: co.paralleluniverse.quasar-core.agent
Bundle-Name: Quasar Agent
Bundle-Version: \${project.version}
"""
    }

    def validateAgentBundle = tasks.register("validateAgentBundle") {
        dependsOn agentBundle
        doLast {
            String importPackages = fetchManifestAttributeFrom(agentBundle, 'Import-Package')
            if (importPackages && !containsOnly(importPackages, ['co.paralleluniverse.common.resource', 'co.paralleluniverse.fibers.suspend'])) {
                throw new InvalidUserDataException("OSGi bundle for Java agent should only import from Java or itself: " + importPackages)
            }
        }
    }

    agentBundle.configure {
        it.finalizedBy validateAgentBundle
    }

    test {
        dependsOn = [shadowJar, bundle, agentBundle, compileClassloadertestJava]
        testClassesDirs = project.sourceSets.test.output.classesDirs
        classpath = project.sourceSets.test.runtimeClasspath

        project.afterEvaluate {
            jvmArgs "-javaagent:${shadowJar.flatMap { it.archiveFile }.get()}" // =vdc
        }
    }

    artifacts {
        shadowedJar shadowJar
        archives shadowJar
        bundleJar bundle
        archives bundle
        agentJar agentBundle
        archives agentBundle
        archives sourcesJar
        archives javadocJar
    }

    check.dependsOn test

    tasks.withType(JavaExec).configureEach {
        classpath += files(sourceSets.test.runtimeClasspath, sourceSets.test.output)
    }
    run.dependsOn compileJava, testClasses

    javadoc {
        options.encoding = 'UTF-8'
        source = sourceSets.main.allJava
    }

    ext {
        osgiArtifacts = {
            it.artifact bundle.flatMap { it.archiveFile }
            it.artifact source: agentBundle.flatMap { it.archiveFile }, classifier: agentBundle.flatMap { it.archiveClassifier }.get()

            it.pom { pom->
                pom.withXml { xml ->
                    def dependenciesNode = xml.asNode().appendNode('dependencies')
                    project.configurations.runtimeClasspath.allDependencies.each {
                        if (! (it instanceof SelfResolvingDependency)) {
                            def dependencyNode = dependenciesNode.appendNode('dependency')
                            dependencyNode.appendNode('groupId', it.group)
                            dependencyNode.appendNode('artifactId', it.name)
                            dependencyNode.appendNode('version', it.version)
                            dependencyNode.appendNode('scope', 'runtime')
                        }
                    }
                }
            }
        }
    }
}

project (':quasar-actors') {
    //project.evaluationDependsOn(':quasar-core')
    
    apply plugin: 'org.javamodularity.moduleplugin'

    ext.moduleName = 'co.paralleluniverse.quasar.actors'
    
    dependencies {
        provided project(path: ':quasar-core', configuration: 'shadowedJar')
        // compile 'org.mutabilitydetector:MutabilityDetector:0.9.2'
        implementation "org.slf4j:slf4j-api:$slf4jVer"
        implementation "net.bytebuddy:byte-buddy:1.9.2"

        testRuntimeOnly "org.apache.logging.log4j:log4j-slf4j-impl:2.11.1"
        testRuntimeOnly "org.apache.logging.log4j:log4j-api:2.11.1"
        testRuntimeOnly "org.apache.logging.log4j:log4j-core:2.11.1"
        testRuntimeOnly "com.lmax:disruptor:3.4.2" // required for log4j
    }
}

project (':quasar-reactive-streams') {
    //project.evaluationDependsOn(':quasar-core')
    
    apply plugin: 'org.javamodularity.moduleplugin'
    ext.moduleName = 'co.paralleluniverse.quasar.reactivestreams'
    
    dependencies {
        provided project(path: ':quasar-core', configuration: 'shadowedJar')
        implementation "org.reactivestreams:reactive-streams:1.0.2"
        testImplementation("org.reactivestreams:reactive-streams-tck:1.0.2") {
            exclude group: "junit", module: "*"
            exclude group: "org.testng", module: "testng"
        }
        testImplementation('org.testng:testng:7.0.0-beta1') {
            exclude group: "com.google.guava", module: "*"
            exclude group: "junit", module: "*"
        }
    }

    test {
        useTestNG()
    }
}

project (':quasar-disruptor') {
    //project.evaluationDependsOn(':quasar-core')
     
    apply plugin: 'org.javamodularity.moduleplugin'
    ext.moduleName = 'co.paralleluniverse.quasar.disruptor'

    dependencies {
        provided project(path: ':quasar-core', configuration: 'shadowedJar')
        implementation "com.lmax:disruptor:3.4.2"
    }
}

javadoc {
    dependsOn subprojects.javadoc
    title = "Quasar ${project(':quasar-core').version}"
    destinationDir = file("docs/javadoc")

    source = project(':quasar-core').sourceSets.main.allJava
    source += project(':quasar-actors').sourceSets.main.allJava
    source += project(':quasar-reactive-streams').sourceSets.main.allJava

    classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })

    options {
         addStringOption('Xdoclint:none')
    }
    excludes = [
        "module-info.java", // for now
        "co/paralleluniverse/actors/spi/**",
        "co/paralleluniverse/actors/ActorMonitor.java",
        "co/paralleluniverse/actors/GlobalRegistry.java",
        "co/paralleluniverse/actors/JMXActorMonitor.java",
        "co/paralleluniverse/actors/LifecycleListener.java",
        "co/paralleluniverse/actors/LifecycleListenerProxy.java",
        "co/paralleluniverse/actors/MutabilityTester.java",
        "co/paralleluniverse/actors/RemoteActorProxyFactoryService.java",
        "co/paralleluniverse/actors/RemoteActorRef.java",
        "co/paralleluniverse/actors/RemoteActorProxyFactory.java",
        "co/paralleluniverse/common/benchmark/**",
        "co/paralleluniverse/common/classloader/**",
        "co/paralleluniverse/common/logging/**",
        "co/paralleluniverse/common/monitoring/**",
        "co/paralleluniverse/common/reflection/**",
        "co/paralleluniverse/common/test/**",
        "co/paralleluniverse/common/util/**",
        "co/paralleluniverse/concurrent/forkjoin/**",
        "co/paralleluniverse/concurrent/util/**",
        "co/paralleluniverse/data/record/DynamicGeneratedRecord.java",
        "co/paralleluniverse/data/record/DynamicRecord.java",
        "co/paralleluniverse/fibers/DefaultFiberPool.java",
        "co/paralleluniverse/fibers/FibersMonitor.java",
        "co/paralleluniverse/fibers/FiberTimedScheduler.java",
        "co/paralleluniverse/fibers/Instrumented.java",
        "co/paralleluniverse/fibers/NoopFibersMonitor.java",
        "co/paralleluniverse/fibers/instrument/**",
        "co/paralleluniverse/io/serialization/**",
        "co/paralleluniverse/remote/**",
        "co/paralleluniverse/strands/channels/SelectActionImpl.java",
        "co/paralleluniverse/strands/channels/disruptor/**", // not ready
        "co/paralleluniverse/strands/queues/**",
    ]
}

clean {
    dependsOn subprojects.clean
    doLast() {
        delete 'docs/javadoc'
    }
}

def publishedProjects = subprojects

configure(publishedProjects) { subproject ->
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.artifactory'

    task sourceJar(type: Jar, dependsOn: subproject.classes) {
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }

//  task javadocJar(type: Jar, dependsOn: subproject.javadoc) {
//    classifier = 'javadoc'
//    from javadoc.destinationDir
//  }
//
    publishing {
        publications {
            if (subproject.hasProperty('osgiArtifacts')) {
                create(subproject.name + '-osgi', MavenPublication) {
                    subproject.osgiArtifacts.call(it)
                    alias true

                    groupId subproject.group
                    artifactId subproject.name + '-osgi'
                    artifact tasks.sourceJar
                    artifact tasks.javadocJar

                    pom {
                        name = subproject.name + '-osgi'
                        packaging = 'jar'
                        description = subproject.description
                        url = subproject.url

                        scm {
                            url = subproject.scmUrl
                            connection = subproject.scmConnection
                            developerConnection = subproject.scmConnection
                        }
                        licenses {
                            license {
                                name = subproject.licenseName1
                                url = subproject.licenseUrl1
                                distribution = 'repo'
                            }
                            license {
                                name = subproject.licenseName2
                                url = subproject.licenseUrl2
                                distribution = 'repo'
                            }
                        }
                        developers {
                            developer {
                                id = 'pron'
                                name = 'Ron Pressler'
                            }
                        }
                    }
                    pom.withXml {
                        Node pomNode = asNode()
                        pomNode.dependencies.'*'.findAll() {
                            it.artifactId.text().startsWith('org.ow2.asm')
                        }.each() {
                            it.parent().remove(it)
                        }
                    }
                }
            }

            create(subproject.name, MavenPublication) {
                from components.java

                groupId subproject.group
                artifactId subproject.name
                artifact tasks.sourceJar
                artifact tasks.javadocJar

                pom {
                    name = subproject.name
                    packaging = 'jar'
                    description = subproject.description
                    url = subproject.url

                    scm {
                        url = subproject.scmUrl
                        connection = subproject.scmConnection
                        developerConnection = subproject.scmConnection
                    }
                    licenses {
                        license {
                            name = subproject.licenseName1
                            url = subproject.licenseUrl1
                            distribution = 'repo'
                        }
                        license {
                            name = subproject.licenseName2
                            url = subproject.licenseUrl2
                            distribution = 'repo'
                        }
                    }
                    developers {
                        developer {
                            id = 'pron'
                            name = 'Ron Pressler'
                        }
                    }
                }
                pom.withXml {
                    Node pomNode = asNode()
                    pomNode.dependencies.'*'.findAll() {
                        it.artifactId.text().startsWith('org.ow2.asm')
                    }.each() {
                        it.parent().remove(it)
                    }
                }
            }
        }
    }
}

artifactory {
    publish {
        contextUrl = 'https://software.r3.com/artifactory'
        repository {
            repoKey = 'corda-dependencies-dev'
            username = project.findProperty('cordaArtifactoryUsername') ?: System.getenv('CORDA_ARTIFACTORY_USERNAME') ?: System.getProperty('corda.artifactory.username')
            password = project.findProperty('cordaArtifactoryPassword') ?: System.getenv('CORDA_ARTIFACTORY_PASSWORD') ?: System.getProperty('corda.artifactory.password')
            maven = true
        }

        defaults {
            if (publishedProjects.contains(project)) {
                publications(project.name)
                publications(project.name + '-osgi')
            }
        }
    }
}
